---
title: "TanStack RouterのLoader機能を理解する"
emoji: "🌊"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: [react, typescript, tanstackrouter, frontend, spa]
published: false
---

## はじめに

SPA でのデータ取得は、ユーザー体験を大きく左右する重要な要素です。従来の React アプリケーションでは、コンポーネントがマウントされた後にデータ取得を開始するため、ローディング状態を表示する必要がありました。

TanStack Router の`loader`機能を使えば、ページ遷移時にコンポーネントのレンダリング前にデータを取得できるため、よりスムーズなユーザー体験を実現できます。本記事では、TanStack Router の`loader`機能の意義と使い方について解説します。

## loader 機能とは

TanStack Router の`loader`機能は、ルートコンポーネントがレンダリングされる前にデータを事前に取得する仕組みです。この機能には以下のようなメリットがあります：

- **宣言的なデータ取得**: ルート定義と同時にデータ依存関係を明示できる
- **パフォーマンス最適化**: ユーザーがページ遷移を開始した時点でデータ取得を始められる
- **キャッシュと再検証**: ルートごとにデータをキャッシュし、必要に応じて再取得できる
- **型安全性**: TypeScript と完全に統合されており、loader からコンポーネントへのデータの受け渡しが型安全

## loader 機能の設定方法

### 1. ルート定義に loader を追加

```tsx
// src/routes/home.tsx
import { createFileRoute } from "@tanstack/react-router";

export const Route = createFileRoute("/_layout/home/")({
  loader: async () => {
    try {
      const response = await getUsers().getUsersHome();
      return response.data;
    } catch (error) {
      console.error("ユーザーデータの取得に失敗しました:", error);
      return { groups: [] };
    }
  },
  component: RouteComponent,
});
```

### 2. コンポーネント内で loader のデータを使用

```tsx
// src/components/RouteComponent.tsx
import { useLoaderData } from "@tanstack/react-router";

function RouteComponent() {
  // loaderの戻り値の型が自動的に推論される
  const data = useLoaderData();

  return (
    <div>
      {/* データを使ったUI構築 */}
      {data.groups.map((group) => (
        <div key={group.id}>{group.name}</div>
      ))}
    </div>
  );
}
```

### 3. キャッシュの無効化とデータの再取得

ユーザーがデータを更新した後、キャッシュされたデータを無効化して再取得したい場合は、`router.invalidate()`を使用します。

```tsx
// src/components/ProfileForm.tsx
import { useRouter } from "@tanstack/react-router";

function ProfileForm() {
  const router = useRouter();

  const onSubmit = async (data: UserData) => {
    try {
      // APIを呼び出してデータを更新
      await putUsersProfileUserId(userId || "", {
        userName: data.userName,
        profileImage: formData.profileImage,
        profileColor: formData.profileColor,
      });

      // ルーターキャッシュを無効化して強制的に再ロードを行う
      router.invalidate();

      toast.success("プロフィール設定に成功しました");
      navigate({ to: "/home" });
    } catch (error) {
      console.error("プロフィール更新エラー:", error);
      toast.error("設定に失敗しました");
    }
  };

  // フォームの実装...
}
```

## 他のライブラリとの比較

### React Router (v6.4 以降)

React Router も同様の loader 機能を提供しています：

```tsx
// src/router.tsx
const router = createBrowserRouter([
  {
    path: "/dashboard",
    element: <Dashboard />,
    loader: async () => {
      return fetchDashboardData();
    },
  },
]);

// src/components/Dashboard.tsx
function Dashboard() {
  const data = useLoaderData();
  // ...
}
```

TanStack Router と比較すると、React Router は型安全性が若干弱く、`useLoaderData`の戻り値の型推論が弱い場合があります。

### Next.js (App Router)

Next.js はサーバーサイドレンダリングを前提としており、データ取得のアプローチが根本的に異なります：

```tsx
// app/dashboard/page.tsx
export default async function Page() {
  // Server Componentで直接データ取得
  const data = await fetchDashboardData();
  return <Dashboard data={data} />;
}
```

Next.js ではサーバーサイドでデータ取得からレンダリングまでを完結させ、完成した HTML をクライアントに送信します。そのため、TanStack Router のようなクライアントサイドでのプリロードは必要ありません。

## TanStack Router と Next.js のアプローチの違い

TanStack Router と Next.js のデータ取得アプローチを比較すると、以下のような違いがあります：

### TanStack Router（クライアントサイド中心）

- **データ取得のタイミング**: クライアントサイドで、ページコンポーネントがレンダリングされる前にデータを事前取得
- **実行環境**: すべてブラウザ上で動作
- **特徴**: SPA では通常、まず UI をレンダリングした後でデータ取得を開始するため、ローディング状態が発生します。loader はこれを最適化し、遷移の開始時点でデータ取得を始めることでユーザー体験を向上させます

### Next.js（サーバーサイド中心）

- **データ取得のタイミング**: サーバー側でレンダリング前にデータを取得
- **実行環境**: サーバーでデータ取得とレンダリングを行い、完成した HTML をクライアントに送信
- **特徴**: ユーザーがページをリクエストした時点で、サーバーがデータ取得からレンダリングまで全て行い、データが埋め込まれた完成品をクライアントに送るため、別途プリロードは不要です

どちらのアプローチもユーザーの待機時間を減らすという同じ目標を持っていますが、アプリケーションの特性に応じて適切な方を選ぶとよいでしょう。

## まとめ

TanStack Router の loader 機能は、SPA でのデータ取得を効率化し、ユーザー体験を向上させる強力な機能です。型安全性の高さと、クライアントサイドでの最適化に優れており、特に TypeScript と組み合わせることで堅牢なアプリケーション開発が可能になります。

一方、Next.js のようなサーバーサイドレンダリングを採用する場合は、また異なるアプローチが有効です。どちらのアプローチを選ぶかは、開発するアプリケーションの要件や、チームの好みによって判断するとよいでしょう.
